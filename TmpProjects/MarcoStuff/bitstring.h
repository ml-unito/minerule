/*****************************************************************
 Specification module : bitstring.h
 Code generated by Object Domain script
     Copyright 95
******************************************************************/


#ifndef BITSTRING_H
#define BITSTRING_H
//#include "bbobj.h"
#include <iostream>
#include <vector>

const int DEBUG_LEVEL = 0;
const int DB_LEVEL_ALL = 1;

using namespace std;

#ifndef CHAR_BIT
#define CHAR_BIT 8
#endif

typedef int boolean;
typedef unsigned int Bits;

// these are default define statements for one to many relations
// you should modify these to reflect the class library you use
class BitString;
/**************************************************************************

**************************************************************************/
class BitString {
vector<Bits> bits;
int n;
int Nw;
enum { Nb=CHAR_BIT * sizeof(Bits) };
void _Xran(int i);
void init(int nbits);
protected:
public:
static int intersections;

//Esistenza dell'elemento di posto  i
boolean test(int i) const
{ if (i<0 || n <= i) return false;
return ((bits[i/Nb] & ((Bits)1 << i%Nb)) != 0); }

BitString();
BitString(int nbits);
BitString(const BitString& bs);
BitString&  set();
BitString&  set(int i,boolean value= true);
BitString&  reset();
BitString&  reset(int i);
BitString&  clear();
BitString&  clear(int i);
BitString&  invert();
BitString&  invert(int i);
BitString&  operator&=(const BitString& bs);
BitString&  operator|=(const BitString& bs);
BitString&  operator^=(const BitString& bs);
BitString&  operator=(const BitString& bs);
boolean operator==(const BitString& bs);
boolean operator!=(const BitString& bs);

//~BitString() {}

BitString  operator&(const BitString& bs1);
friend ostream&  operator<<(ostream& out,const BitString& bs);
friend istream&  operator>>(istream& in,BitString& bs);

int count(boolean what = true) const ;
bool moreThan(float threshold) const ;
int length() const { return n; }
int ssize() const { return bits.size(); }
int size() const { return n; }

void serialize(char* serialized,int* start);
void unserialize(char* serialized,int* start);
void print();
void print(ostream& out);


void setNBit(int num) {Nw = (num == 0) ? 0 : (num-1) / Nb;n=num;}
void* getElmA(int which) {return &(bits[which]);}
Bits getElm(int which) {return bits[which];}
void insert(Bits element) {bits.push_back(element);}
vector <Bits>& gbits() {return bits;}

char operator[](int which) const { return (test(which) ? '1' : '0'); }
//boolean operator[](int which) { return test(which); }

};


#endif
