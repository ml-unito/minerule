# Options related to the MRDB connection
mrdb::{
  +name=selex
  +username=postgres
  +password=selex
  +cacheWrites=False
# dbms allows one to specify the underlying dbms, supported dbms are presently
# mysql and postgres
  +dbms=postgres
}

# Options related to data safety issues
safety::{
# if the following option is set to 'True', then the
# system will delete old results whenever a new minerule
# having the same name of an old one is inserted. Otherwise
# the system will report an error message and exit.
  +overwriteHomonymMinerules=False
# if overwriteHomonymMinerules is set to True, then the
# following option decides whether the system should delete
# also the minerules for which the result depends on the 
# deleted one. If the option is set to True, those 
# minerule will be deleted as well, otherwise the system 
# with halt reporting an error.
  +allowCascadeDeletes=False
}

# Options related to mining algorithms
miningalgorithms::{
  #options for configuring rule mining algorithms
  rulesmining::{
    +preferredAlgorithm=None

    # Options related to PartitionBase algorithm
    partitionbase::{
      +rowsPerPartition=300000
    }

    # Options related to PartitionWithClusters algorithm
    partitionwithclusters::{
      +rowsPerPartition=300000
    }

    # Options related to FPGrowth algorithms
    fpgrowth::{
      +algoType=Original
    }
  }
 itemsetsmining::{
    +preferredAlgorithm=None

 }
}

# Options related to Optimizations
optimizations::{
  +enableOptimizations=False
# If set to True, this option will disable the detection of dominant
# queries (this imply also that the system will not try to find equivalent
# queries, since they are a particular case of dominance)
  +avoidDominanceDetection=False
# If set to True this option will make the optimizer to 
# consider equivalent queries as if they were dominant ones
# (i.e., it will call an incremental algorithm instead of
# dealing with the equivalence).
  +avoidEquivalenceDetection=False
# If set to True the optimizer will not try to find 
# a combinations of previous queries equivalent to the current one.
# Notice that the search for combination may be a slow process
  +avoidCombinationDetection=False
# The following option allows the user to specify how a 
# particular incremental algorithm  have to be chosen. The
# following values are allowed:{Constructive,Destructive,
# Auto}
# Constructive and Destructive force the corresponding 
# algorithm to be chosen. 
# Auto leaves the choice to the optimizer.
  +incrementalAlgorithm=Auto
# Options related to the query combinator algorithm
  combinator::{
# amount of time the search for a combination is allowed to run 
    +timeOut=4
# Max number of disjuncts. It is the number of disjuncts that is considered
# during the search. Notice that increasing this number has a strong impact
# on the dimension of the search space.
    +maxDisjuncts=3
# Max number of queries. Max number of distinct queries the user allows to
# be combined in the result. Formulae with a larger number of queries are
# penalized in the evaluation function.
    +maxQueries=5
# Max distinct predicates. Max number of distinct predicates that the user
# allows. This afflict the response time: the time spent in assessing each
# formula grows exponentially fast with the number of predicates.
    +maxDistinctPredicates=10
  }
}

# Options related to the parsing algorithms
parsers::{
# Parsers log stream, valid names are:
#   <stdout>, <stderr> and any writeable file.
 +logfile=/dev/null
# The following four options allows to set constraint on
# cardinalities of elements which appears in the body/head
# part of rules. The constraints set here 'win' on the ones
# in minerules (i.e., if you say '1..n' as BODY in your minerule
# but set it to 1..5 here, than 1..5 will be used instead.
 +minBodyElems=1
 +maxBodyElems=1000
 +minHeadElems=1
 +maxHeadElems=1000
}

# Options related to streams, note that they are commented.
# the reason is that the following conresponds to default 
# settings instead of the actual ones.
# In specifying the stream parameter, you can:
# 1) Specify a file path
# 2) Specify <stdout>,<stderr> in order to specify the standard
#    output and the standard error respectively
# 3) Specify a file path including the %m and %i symbols
# In case 3) %m is expandend to the current minerule name as
# it appear in the minerule text, %i is expanded to the value
# of the -i parameter if any, to 'mr' otherwise
# The loglevel option allows you to select how deep the log nesting
# can grow. The default (loglevel==100) means: "grow as much as needed"
# (no function in minerule will ever nest logs more than a few levels).
# If set to 0, then the log is actually suppressed (the first level is 1).
# Otherwise, if set to n, only the first n levels will be displayed.
#
# logstream::{
#    +stream=<stdout> 
#    +loglevel=100
# }
# errstream::{
#    +stream=<stderr> 
#    +loglevel=100
# }
# warnstream::{
#    +stream=<stdout> 
#    +loglevel=100
# }
# debugstream::{
#    +stream=<stderr> 
#    +loglevel=100
# }
