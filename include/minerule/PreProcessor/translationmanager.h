//   Minerule - a sql-like language for datamining
//   Copyright (C) 2013 Roberto Esposito (esposito@di.unito.it)
//
//   This program is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#ifndef __TABLETRANSLATIONMANAGER__H__
#define __TABLETRANSLATIONMANAGER__H__

#include<odbc++/drivermanager.h>
#include<odbc++/connection.h>
#include<odbc++/resultset.h>
#include<odbc++/statement.h>
#include<odbc++/resultsetmetadata.h>
#include<odbc++/types.h>

using namespace::std;

#define BBLOG(a) do { std::cerr << a << std::endl; } while(0)

#include "translatedtable.h"


/**
 * As a way to optimize queries, we translate each value in the DB to
 * numerical identifiers. This class perform the translation and
 * provide a way to access to the resulting tables and values by means
 * of the translateTable method.
 *
 * We refer to tables containing untranslated values as "original
 * tables" while the table generated by this class will be referred to
 * as "translated tables". Analogously, we refer to untranslated
 * values as "original values" and to new ones created by this class
 * as "translated values".
 *
 * In order to fully abstract the access to the new tables, we provide
 * a translation function for the table column names as well (at the
 * present time the functions implementing this functionality simply
 * returns its input, but this behavior may change in the future).
 *
 * @author Roberto Esposito (esposito@di.unito.it)
 */

namespace minerule {

class TranslationManager {
 protected:
  /** 
   * Once a column in a table get translated, a new table is created
   * to hold the associations between its original values and their
   * translations.  The method returns the name of the translation
   * table for column columnName of table tableName.
   *
   * @param tableName the original table name
   * @param columnName a column of table "tableName"
   */
  
 std::string 
    getTranslationTableNameForColumn(const std::string& tableName,
				     const std::string& columnName) const;

  /**
   * It returns a column name of `getTranslationTableNameForColumn(tableName,
   * columnName)`. In particular it returns the column that holds the 
   * translated values.
   *
   * @param tableName
   * @param columnName
   */
  string
    getTranslatedColumnNameForColumn(const std::string& tableName, 
				     const std::string& columnName) const;
  /**
   * It returns a column name of `getTranslationTableNameForColumn(tableName,
   * columnName)`. In particular it returns the column that holds the 
   * original values.
   *
   * @param tableName
   * @param columnName
   */
  string
    getOriginalColumnNameForColumn(const std::string& tableName,
				   const std::string& columnName) const;
 /**
   * It returns the name of the translated table associated to table
   * tableName. This function does not access to the dictionary table to
   * get the name and hence should be used only to know how the table name
   * should look like (probably you want to use it when you create the 
   * translation table).
   *
   * @param tableName
   */

  string
    getTranslationTableNameForTable( const std::string& tableName ) const;
 public:
    
  /**
   * If "tableName" has never been translated the function translates
   * the values in "tableName", sets up any structure necessary to
   * keep track of the mapping, and returns the object needed to
   * access to the translated values, otherwise it simply returns the
   * access object for the translated values.  The function * throws a
   * SQLException exception if something goes wrong (in particular if
   * tableName does not exist in the current DB).
   *
   * Note: is left to the user the duty of freeing the returned
   * TranslatedTable object when it is no longer useful.
   *
   * @param tableName the name of a table in the current DB 
   * 
   * @return a TranslatedTable, that is an object allowing to access
   * to the translated values.
   */
  virtual TranslatedTable* 
    translateTable(const std::string& tableName) const = 0;

  /**
   * Look up if, in the current DB, there is an original table whose
   * name is tableName and for which a translatedTable already exists.
   * If so, it returns <true, nameOfTranslatedTable>, otherwise it
   * returns <false, astring> where std::string contains an unpredictable
   * value.
   *
   * @param tableName the name of the original table 
   *
   * @return <bool,string> see above description 
   *
   * @throw SQLException whenever something weird occurs with the odbc
   * connection
   */
  virtual pair<bool,string> 
    alreadyTranslated(const std::string& tableName) const 
    throw(odbc::SQLException) = 0;
};

}
#endif
