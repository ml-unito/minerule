//   Minerule - a sql-like language for datamining
//   Copyright (C) 2013 Roberto Esposito (esposito@di.unito.it)
//
//   This program is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with this program.  If not, see <http://www.gnu.org/licenses/>.
/*****************************************************************
Specification module : bitstring.h
Code generated by Object Domain script
Copyright 95
******************************************************************/


#ifndef BITSTRING_H
#define BITSTRING_H

#include <iostream>
#include <vector>
#include <string.h>
#include <stdio.h>
	
#ifndef CHAR_BIT
#define CHAR_BIT 8
#endif
	
namespace minerule {

	const int DEBUG_LEVEL = 0;
	const int DB_LEVEL_ALL = 1;



	typedef int boolean;
	typedef unsigned int Bits;



	class BitString {
		std::vector<Bits> bits;
		int n;
		int Nw;
		enum { Nb=CHAR_BIT * sizeof(Bits) };
		void _Xran(int i);
		void init(int nbits);
	public:
		static int intersections;

		//Esistenza dell'elemento di posto  i
		boolean test(int i) const { 
			if (i<0 || n <= i) return false;
			return ((bits[i/Nb] & ((Bits)1 << i%Nb)) != 0); 
		}

		BitString();
		BitString(int nbits);
		BitString(const BitString& bs);
		BitString&  set();
		BitString&  set(int i,boolean value= true);
		BitString&  reset();
		BitString&  reset(int i);
		BitString&  clear();
		BitString&  clear(int i);
		BitString&  invert();
		BitString&  invert(int i);
		BitString&  operator&=(const BitString& bs);
		BitString&  operator|=(const BitString& bs);
		BitString&  operator^=(const BitString& bs);
		BitString&  operator=(const BitString& bs);
		boolean operator==(const BitString& bs);
		boolean operator!=(const BitString& bs);

		BitString  operator&(const BitString& bs1);
		friend std::ostream&  operator<<(std::ostream& out,const BitString& bs);
		friend std::istream&  operator>>(std::istream& in,BitString& bs);

		int count(boolean what = true) const ;
		bool moreThan(double threshold) const ;
		int length() const { return n; }
		int ssize() const { return bits.size(); }
		int size() const { return n; }

		void serialize(char* serialized,int* start);
		void unserialize(char* serialized,int* start);
		void print();
		void print(std::ostream& out);


		void setNBit(int num) 		{  Nw = (num == 0) ? 0 : (num-1) / Nb;n=num; }
		void* getElmA(int which) 	{  return &(bits[which]); }
		Bits getElm(int which) 		{  return bits[which]; }
		void insert(Bits element) 	{  bits.push_back(element); }
		std::vector <Bits>& gbits() {  return bits; }

		char operator[](int which) const { return (test(which) ? '1' : '0'); }

	};

} //end namespace

#endif
