/*
   Minerule - a sql-like language for datamining

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

%{

#include "minerule/Parsers/ParsedPredicate.h"
#include "minerule/Parsers/HeaderQuery.h"
#include "minerule/Parsers/SupportMeasure.h"
#include "MineruleParser_parser.hpp"
#include <string.h>
#include "minerule/Utils/Converter.h"
#include <sstream>
#include <map>
#include <iostream>

using namespace minerule;


int mrlex();  

#define PARSER_BUF_SIZE (1<<14)

char linebuf[PARSER_BUF_SIZE];
int tokenpos=0;
int lastC=0;
char* stringUpperCase(char*);
std::map<std::string,int> keywords_to_token;
 
void append_to_linebuf(char* str);
%}

%option noinput
%option nounput

KEYWORDS ("MINE"|"RULE"|"AS"|"SELECT"|"DISTINCT"|"BODY"|"HEAD"|"AND"|"OR"|"NOT"|"FROM"|"GROUP"|"BY"|"HAVING"|"EXTRACTING"|"RULES"|"WITH"|"WHERE"|"CLUSTER"|"ITEMSET"|"SUPPORT"|"CONFIDENCE"|"SEQUENCE"|"SEQUENCES"|"ORDER"|"ITEMSETS"|"GAP")
AGGR ("MAX"|"MIN"|"AVG"|"STD"|"SUM")
ATTRNAME  ([a-zA-Z][a-zA-Z0-9_]*)
QUOTED_STRING  (['][^']*['])

%%

[ ]+		      {	tokenpos=tokenpos+mrleng;
					append_to_linebuf(mrtext);			
		      }

[,"():]               { tokenpos=tokenpos+mrleng;
			append_to_linebuf(mrtext);
			return mrtext[0];
		      }

(<)|(>)|(<=)|(>=)|(<>)|(=)			 {
							tokenpos=tokenpos+mrleng;
							append_to_linebuf(mrtext);
							mrlval.TString=strndup(mrtext,PARSER_BUF_SIZE);
							return(COMPARISON);
						 }


{KEYWORDS}		{
				char* stringUpperCase(char*);
				tokenpos=tokenpos+mrleng;
                                append_to_linebuf(mrtext);
				return keywords_to_token[stringUpperCase(mrtext)];
			}

(-?[1-9][0-9]*|0)		{
			 		tokenpos=tokenpos+mrleng; 
			 		append_to_linebuf(mrtext); 
					mrlval.TString=strndup(mrtext,PARSER_BUF_SIZE);
			 		return(INT_NUMBER);
 			}

\.\.                    {
				tokenpos=tokenpos+mrleng; 
				append_to_linebuf(mrtext); 
				return(DOTS);
			 }


BODY\.{ATTRNAME}              {
				tokenpos=tokenpos+mrleng;
                                append_to_linebuf(mrtext);
				mrlval.TString=strndup(mrtext,PARSER_BUF_SIZE);
				return(PARTBODY);
			}

HEAD\.{ATTRNAME}              {
				tokenpos=tokenpos+mrleng;
                                append_to_linebuf(mrtext);
				mrlval.TString=strndup(mrtext,PARSER_BUF_SIZE);
				return(PARTHEAD);
			}

{AGGR}			 {
                          tokenpos=tokenpos+mrleng;
                          append_to_linebuf(stringUpperCase(mrtext));
                          mrlval.TString=strndup(stringUpperCase(mrtext),PARSER_BUF_SIZE);
                          return(AGGREGATE);
			}


{ATTRNAME}		{	
			  tokenpos=tokenpos+mrleng;
			  
			  append_to_linebuf(mrtext);
			  mrlval.TString=strndup(mrtext,PARSER_BUF_SIZE);
			  return(ATTR);
		        }

{QUOTED_STRING}		{	
			 if(!lastC) {
				tokenpos=0;
				linebuf[0]='\0';
			 }
			 tokenpos=tokenpos+mrleng;
			 append_to_linebuf(mrtext);
			 mrlval.TString=strndup(mrtext,PARSER_BUF_SIZE);
 			 return(QUOTED_VALUE);
			}
		

(-?[0-9]+"."[0-9]+)|(-?[0-9]+[e|E]-?[0-9]+)    {	tokenpos=tokenpos+mrleng;
							append_to_linebuf(mrtext);				
							mrlval.TString=strndup(mrtext,PARSER_BUF_SIZE);
							return(DBL_NUMBER);
			     }

\n  			{
						if (lastC) {
								tokenpos=tokenpos+mrleng;
								append_to_linebuf(mrtext);
								lastC=0;
								return 0;
						} else {	
							 	tokenpos=0;
							 	linebuf[0]='\0';
						}
				}

%%

void append_to_linebuf(char* str) {
	int curlen = strlen(linebuf);
	int charsLeft = PARSER_BUF_SIZE - curlen - 1; 
	if( charsLeft < 0) {
		std::cout << "Buffer overflow!" << std::endl;
	}
	
	if( charsLeft == 0 ) {
		std::cout << "append_to_linebuf: No more space on the buffer..., skipping buffer append!";
	} else {
/*		std::cout << "appending " << strlen(str) << " chars to buffer (chars left:" << charsLeft << " )" << std::endl;*/
		strncat(linebuf, str, charsLeft);
	}
}

void mrerror(char const *s){
	char buf[4096];
	std::stringstream ss;
	ss << s << " at column: " << tokenpos << std::endl << linebuf << std::endl;
	for(int i=0; i<tokenpos+1; ++i)
	   buf[i]=' ';		
	buf[tokenpos+1]='\0';
	ss << buf << "^" << std::endl;
	throw MineruleException(MR_ERROR_MINERULETEXT_PARSING, ss.str() );
}

int mrwrap() {
	return 1;
}

//This function converts from very small to capital one world
//received from the lexer
char*
stringUpperCase(char* mrtext) {
  int len=strlen(mrtext);
  for(int i=0;i<len;++i) {
    mrtext[i]=toupper(mrtext[i]);
  }
  return mrtext;
}





