//   Minerule - a sql-like language for datamining
//   Copyright (C) 2013 Roberto Esposito (esposito@di.unito.it)
//
//   This program is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#include "minerule/Utils/Bitstring.hpp"

namespace minerule {



static int NBITS[] = {
0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1,
2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2,
2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3,
4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3,
2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3,
4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4,
4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5,
6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4,
2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3,
4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4,
4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5,
6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5,
4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5,
6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6,
6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
};

/*****************************************************************
 Body module : bitstring.cpp
 Code generated by Object Domain script
     Copyright 95
******************************************************************/


int BitString::intersections = 0;
/*************************************************************************
   BitString::init

**************************************************************************/
void BitString::init(int nbits)
{
n = nbits;
Nw = (n == 0) ? 0 : (n-1) / Nb;
for (int i=0; i<=Nw; i++) bits.insert(bits.end(),(Bits)0);
}

/*************************************************************************
   BitString::BitString

**************************************************************************/
 BitString::BitString() { init(0); }

 BitString::BitString(int nbits)
{
init(nbits);
}

BitString::BitString(const BitString& bs) {
n = bs.n;
Nw = bs.Nw;
for (int i=0; i<=Nw; i++) bits.insert(bits.end(),bs.bits[i]);
}

/*************************************************************************
  BitString BitString::set

**************************************************************************/
BitString&  BitString::set()
{
for (int i=0; i<=Nw; i++) bits[i] = ~(Bits)0;
return *this;
}

/*************************************************************************
  BitString BitString::set

**************************************************************************/
BitString&  BitString::set(int i, boolean value)
{
if (n <= i) _Xran(i);
if (value) bits[i/Nb] |= (Bits)1 << i%Nb;
else bits[i/Nb] &= ~((Bits)1 << i%Nb);
return *this;
}

/*************************************************************************
  BitString BitString::reset

**************************************************************************/
BitString&  BitString::reset()
{
for (int i=0; i<=Nw; i++) bits[i] = (Bits)0;
return *this;
}

/*************************************************************************
  BitString BitString::reset

**************************************************************************/
BitString&  BitString::reset(int i)
{
return set(i, false);
}

/*************************************************************************
  BitString BitString::clear

**************************************************************************/
BitString&  BitString::clear()
{
for (int i=0; i<=Nw; i++) bits[i] = (Bits)0;
return *this;
}

/*************************************************************************
  BitString BitString::clear

**************************************************************************/
BitString&  BitString::clear(int i)
{
return set(i, false);
}

/*************************************************************************
  BitString BitString::invert

**************************************************************************/
BitString&  BitString::invert()
{
for (int i=0; i<=Nw; i++) bits[i] = ~bits[i];
return *this;
}

/*************************************************************************
  BitString BitString::invert

**************************************************************************/
BitString&  BitString::invert(int i)
{
if (n <= i) _Xran(i);
bits[i/Nb] ^= (Bits)1 << i%Nb;
return *this;
}

/*************************************************************************
  BitString BitString::operator|=

**************************************************************************/
BitString&  BitString::operator|=(const BitString& bs)
{
if (n < bs.n) {
	for (; n < (Nw+1)*Nb && n < bs.n; n++) reset(n);
	n = bs.n;
}
if (Nw < bs.Nw) {
	for (; Nw <= bs.Nw; ) { Nw++; bits.insert(bits.end(), (Bits)0); }
}
for (int i=0; i<=bs.Nw; i++) bits[i] |= bs.bits[i];
return *this;
}

/*************************************************************************
  BitString BitString::operator^=

**************************************************************************/
BitString&  BitString::operator^=(const BitString& bs)
{
if (n < bs.n) {
	for (; n < (Nw+1)*Nb && n < bs.n; n++) set(n,bs.test(n));
	n = bs.n;
}
if (Nw < bs.Nw) {
	for (; Nw < bs.Nw; ) { Nw++; bits.insert(bits.end(), bs.bits[Nw]); }
}
for (int i=0; i<=bs.Nw; i++) bits[i] ^= bs.bits[i];
return *this;
}

/*************************************************************************
  BitString BitString::operator&=

**************************************************************************/
BitString&  BitString::operator&=(const BitString& bs)
{
/*
if (n < bs.n) {
	for (; n < (Nw+1)*Nb && n < bs.n; n++) set(n);
	n = bs.n;
}
if (Nw < bs.Nw) {
	for (; Nw < bs.Nw; ) { Nw++; bits.insert(bits.end(), ~(char)0); }
	n = bs.n;
}
for (int i=0; i<=bs.Nw; i++) bits[i] &= bs.bits[i];
*/
if (Nw < bs.Nw) {
	for (int i=0; i<=Nw; i++) bits[i] &= bs.bits[i];
} else { 
	int i;
	for (i=0; i<=bs.Nw; i++) bits[i] &= bs.bits[i];
	for (; i<=Nw; i++) bits[i] = (Bits)0;
}
intersections++;
return *this;
}

/*************************************************************************
  BitString BitString::operator&

**************************************************************************/
BitString  BitString::operator&(const BitString& bs1)
{
	BitString bs;
	int min = Nw < bs1.Nw ? Nw : bs1.Nw;
	for (int i=0; i<=min; i++) bs.bits.insert(bs.bits.end(),bits[i] & bs1.bits[i]);
	bs.Nw = min;
	bs.n = n < bs1.n ? n : bs1.n;
	return bs;
}

/*************************************************************************
  BitString BitString::operator=

**************************************************************************/
BitString&  BitString::operator=(const BitString& bs)
{
bits.erase(bits.begin(),bits.end());
n = bs.n;
Nw = bs.Nw;
for (int i=0; i<=Nw; i++) bits.insert(bits.end(),bs.bits[i]);
//for (int i=0; i<=Nw && i<=bs.Nw; i++) bits[i] = bs.bits[i];
return *this;
}

/*************************************************************************
  BitString BitString::operator==

**************************************************************************/
boolean BitString::operator==(const BitString& bs)
{
boolean eq = n == bs.n;
for (int i=0; i<Nw && eq; i++) eq = bits[i] == bs.bits[i];
for (int i=(Nw-1)*Nb; i<n && eq; i++) eq = test(i) == bs.test(i);
return eq;
}

/*************************************************************************
  BitString BitString::operator!=

**************************************************************************/
boolean BitString::operator!=(const BitString& bs)
{
return !operator==(bs);
}

/*************************************************************************
  void BitString::_Xran

**************************************************************************/
void BitString::_Xran(int i)
{
//std::cerr << "BitString index out of range: " << i << std::endl;
int newNw = i/Nb;
for (int j=Nw+1; j<=newNw; j++) bits.insert(bits.end(),(Bits)0);
n = i+1; Nw = newNw;
}

/*************************************************************************
  int BitString::count

**************************************************************************/
int BitString::count(boolean what) const
{
int i,j, k=0;
for (i=0; i<=Nw; i++) {
//	Bits b = bits[i];
//	for (int j=0; j<Nb && b!=0; j++) { k+=b&0x01; b>>=1;}
	for (j=0; j<sizeof(Bits); j++)
	k += NBITS[*(((unsigned char*)&bits[i])+j)];
}
//for (i=0, k=0; i<n; i++) if (test(i) == what) k++;
return k;
}

/*************************************************************************
  bool BitString::moreThan

**************************************************************************/
bool BitString::moreThan(double threshold) const
{
int i,j, k=(int)(threshold);
for (i=0; i<=Nw && k >= 0; i++) {
//	Bits b = bits[i];
//	for (int j=0; j<Nb && b!=0; j++) { k+=b&0x01; b>>=1;}
	for (j=0; j<sizeof(Bits); j++)
	k -= NBITS[*(((unsigned char*)&bits[i])+j)];
}
//for (i=0, k=0; i<n; i++) if (test(i) == what) k++;
return k<0;
}

/*************************************************************************
  std::ostream BitString::operator<<

**************************************************************************/
std::ostream& operator<<(std::ostream& out, const BitString& bs)
{
for (int i=0; i<bs.n; i++) out << (bs.test(i) ? '1' : '0');
return out;
}

/*************************************************************************
  istream BitString::operator>>

**************************************************************************/
std::istream& operator>>(std::istream& in, BitString& bs)
{
std::ios::iostate St = std::ios::goodbit;
boolean Chg = false;
int C = in.rdbuf()->sgetc();
bs.reset();
while (C != EOF && C == ' ') C = in.rdbuf()->snextc();
for (size_t M = 0; true ; C = in.rdbuf()->snextc(), ++M)
{
	if (C == EOF) {St |= std::ios::eofbit; break; }
	else if (C != '0' && C != '1') break;
	//else if (_X.allocation() <= _X.length())
	//      {_St |= ios::failbit;
	//      break; }
	else { bs.set(M,C=='1'); Chg = true; }
}
//if (!_Chg)  _St |= ios::failbit;
in.setstate(St);
return (in);
}


//MARCO

void BitString::serialize(char* serialized,int* start)
{int i;

 memcpy(&(serialized[(*start)]),&Nw,sizeof(int));
	//cout<<int(serialized[(*start)])<<" "<<std::endl;
 //cout<<"\"";
 (*start) += sizeof(int);
 memcpy(&(serialized[(*start)]),&n,sizeof(int));
 (*start) += sizeof(int);
	for (i=0;i<=Nw;i++)
	{
	 memcpy(&(serialized[(*start)]),&(bits[i]),sizeof(Bits));
	 //cout<<(int)(serialized[(*start)])<<" ";
		(*start) += sizeof(Bits);
	}
}

void BitString::unserialize(char* serialized,int* start)
{int i;
 char tmpchar;

 memcpy(&Nw,&(serialized[(*start)]),sizeof(int));
	//cout<<int(serialized[(*start)])<<" "<<std::endl;
 //cout<<"\"";
 (*start) += sizeof(int);
 memcpy(&n,&(serialized[(*start)]),sizeof(int));
 (*start) += sizeof(int);
 for (i=bits.size();i<=Nw;i++) bits.insert(bits.end(),(Bits)0);
	for (i=0;i<=Nw;i++)
	{
	 memcpy(&tmpchar,&serialized[(*start)],sizeof(Bits));
	 //cout<<(int)(serialized[(*start)])<<" ";
	 bits[i] = tmpchar;
	 (*start) += sizeof(Bits);
	}
// setNBit(numbit);
}

void BitString::print(std::ostream& out)
{int i,dim;

 if (DB_LEVEL_ALL<=DEBUG_LEVEL)
 {
 dim=(*this).length();
 for (i=0;i<dim;i++)
 {
  if ((i%8==0)&&(i!=0)) out<<"-";
  out<<test(i);
 }
 }
}

void BitString::print()
{int i,dim;

 if (DB_LEVEL_ALL<=DEBUG_LEVEL)
 {
 dim=(*this).length();
 for (i=0;i<dim;i++)
 {
  if ((i%8==0)&&(i!=0)) std::cout<<"-";
  std::cout<<test(i);
 }
 }
}

} // end namespace
