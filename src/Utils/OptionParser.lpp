%{
#include <iostream>
#include "Utils/MineruleException.h"


using namespace minerule;

#define YYSTYPE std::string	
#include "OptionParser_parser.hpp"

// #define LEXDBG(a) a
#define LEXDBG(a)
%}

%option noyywrap
%option noinput
%option nounput

STR [a-zA-Z0-9\.\/\-_]*
COMMSTR .*
  
%%

[ \t\n]*	{/* ignore them */  LEXDBG(cerr << "flex ignoring spaces" <<endl;)}
\".*\"		{
				std::string inStr=OPtext;  
				std::string resStr(inStr, 1, inStr.length()-2);
				OPlval = resStr;
				LEXDBG(cerr << "flex: VALSTRING (" << OPlval <<")"<< endl;)
				return STRING;
			}

{STR}		{ 
				OPlval = OPtext; 
				LEXDBG(cerr << "flex: VALSTRING (" << OPtext <<")"<< endl;)
				return STRING;
			}
\<{STR}\>	{ 
				OPlval = OPtext;
		  	  	LEXDBG(cerr << "flex: VALSTRING (" << OPtext <<")"<< endl;)
		  	  	return STRING;
			}
#{COMMSTR}\n	{
				/* ignore this token */ 
				LEXDBG(cerr <<"flex: commennt ignored" <<endl;)
				}

=			{ 
				LEXDBG(cerr << "flex: EQSIM" <<endl;) 
		  		return EQSIM; 
			}

:: 			{ 
				LEXDBG(cerr << "flex:sep" <<endl;)
		  	  	return NSSEP; 
			}

\{			{ 
				LEXDBG(cerr << "flex:left" << endl;)  	
		  	  	return LEFTBRACE; 
			}

\}			{ 
				LEXDBG(cerr << "flex:right" << endl;) 
		  	  	return RIGHTBRACE; 
			}	

\+           {
				LEXDBG(cerr << "flex:-" << endl;)
				return STARTOPT;
			}

%%

extern int OPparse();

int OPerror(char const* error) {
	throw MineruleException(MR_ERROR_OPTION_PARSING,error);
}

